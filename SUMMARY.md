# Summary
This guide provides information on how we used the artifacts during the experiments and post-processing of the results.
First, we initiate the 12-hour experiment with configuration variety using repairer.sh script.
The script will take a random start and end date and an arbitrary syzkaller configuration file taken from the syzbot dashboard.
It will collect all the commit IDs belonging to the interval between start and end dates.
Next up, it will check the commit IDs one by one against the configuration file with koverage to see if the configuration file includes lines in the patch commit.
If not, klocalizer will be used to repair the configuration file to include those lines.
Then, a kernel image will be built with the repaired configuration file and syzkaller will start fuzzing the image for 12 hours.

The same 12-hour experiment will be conducted without configuration variety using original syzkaller configurations using repairer_script/fuzzing_experiments.sh script.
Next, we will use the scripts to post-process the results of the experiments.
In the beginning, we analyze crash folders of each run of fuzzing with and without configuration variety to check whether previously unreported bugs are present and need to be reported to the Linux kernel mailing list.
To check whether a bug is previously unreported we manually analyze the bug's alarm name and call trace and compare it with the existing bug reports with the same description in the Linux kernel mailing list.

If the bug is previously unreported, we report it to the Linux kernel mailing list. To report the bug, we use the following steps:
1. We first determine at what source file the bug occurred from the syzkaller bug report.
2. Next, we provide the file name to the script called ./scripts/get_mainter.pl to obtain the email addresses of the maintainers of the file.
3. Then, we generate a bug report and include the head commit ID of the Linux-next version we fuzzed, link to the kernel configuration file used to build the kernel, a reproducer file (if exists) to reproduce the crash, and syzkaller bug report of the crash.

find_reproducers.sh can be used to find reproducers of the crashes found during the aforementioned experiment, fuzzing with and without configuration variety. Reproducers are necessary to be included in the bug reports as they help the maintainers analyze the crash. They are also useful to check whether the crash is reproducible on the kernel built with the original syzkaller configuration files.
To be able to check that, we use collect_reproducers.sh to sort reproducers based on their type (C or syz programs) and then manually upload them to kernel emulated with QEMU to see if they crash.

We also use build_kernel.sh, script to build kernel images based on a provided set of configuration files and commit tags to checkout.
We also analyze whether the crash is the result of configuration option changes our tool made while repairing the syzkaller configuration file. For instance, we used ifdef_find_bug_relevance.py to check whether configuration options related to files that contain definitions of functions found in the call trace of a bug's syzkaller report or configuration options related to conditional blocks that may cover the call of those functions exist in configuration files with and without configuration variety.
If there are configuration options that exist in the repaired configuration and not in the original syzkaller configuration and if that option caused a source file that contained the definition of a function found in the call trace of the bug to be included, or it caused an #ifdef conditional block to that covered the call of the function to be included, we consider that our changes led to the crash.

In addition, we instrumented reproducer files generated by syzkaller to have KCOV visibility to get program counters executed by the reproducer. We later converted those program counters to source code lines and checked if those lines existed inside of an #ifdef conditional block that turned true with our modification to a configuration option, with the help of addr2line_inside_ifdef.py.

We also analyze and deduplicate the alarms found during the experiments with and without configuration variety using the scripts find_unique_crash.py and bugs_unique_and_common.py. With the help of these scripts, we also check the bugs found that are unique to each experiment and the bugs that are common to both experiments. These results can be found in data_tables/Repaired-SYZKALLER Deduplicated Crash name+Trace(Bug Finding+Coverage).xlsx and data_tables/Repaired-SYZKALLER Only Crash+Call Trace(Bug Finding+Coverage).xlsx.
Overall, more information about the experiments and the results can be found in data_tables/Table_of_all_crashes.xlsx.


